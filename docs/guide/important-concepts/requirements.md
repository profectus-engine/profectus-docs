# Requirements

The requirements system in Profectus is designed to handle various conditions that must be met before certain actions or features can be accessed by the player. These conditions can include resource amounts, completed challenges, or other milestones within the game.

## Creating Requirements

To create a requirement, you can use one of the provided utility functions like [createCostRequirement](/api/game/requirements/functions/createCostRequirement), [createVisibilityRequirement](/api/game/requirements/functions/createVisibilityRequirement), or [createBooleanRequirement](/api/game/requirements/functions/createBooleanRequirement). These functions return a `Requirement` object with specific properties that define the requirement conditions.

Cost requirements are probably the most common requirement you'll be using. For something with multiple levels, like repeatables, you'll typically want to use a formula for the cost instead of a function, and the input to the formula will be the repeatable's `amount` property. Typically that means the code will look like this:

```ts
const repeatable = createRepeatable(() => ({
    requirements: createCostRequirement(() => ({
        resource: noPersist(points),
        cost: Formula.variable(repeatable.amount).add(1).times(100)
    }))
}));
```

## Using Requirements

Several features will have a `requirements` property that takes one or more requirements that must be fulfilled for a certain action to be performed with that feature.

When implementing requirements, you can use the [displayRequirements](/api/game/requirements/functions/displayRequirements) utility. This utility is designed to give a human-readable string generated by the requirement(s) given, making it easier for players to understand the conditions needed to progress in the game. Typically features that support requirements will already use this utility internally.

You may need to "pay" requirements upon meeting their conditions and performing the associated action. This action typically involves spending resources or making other adjustments to the game state. The [payRequirements](/api/game/requirements/functions/payRequirements) function simplifies this process by handling the payment for one or more requirements, considering the number of levels to pay for. Additionally, custom pay functions like [payByDivision](/api/game/requirements/functions/payByDivision) and [payByReset](/api/game/requirements/functions/payByReset) can be passed into `createCostRequirement` for more specialized cases.

## Multi-Level Requirements

Requirements can have multiple "levels", which are typically used for things like multi-level challenges with scaling requirements. When checking if requirements are met, the [requirementsMet](/api/game/requirements/functions/requirementsMet) function can be used. It accepts a single requirement or an array of requirements.

Requirements that are just on/off, such as boolean or visibility requirements, will count as infinite levels when in the same array. This allows you to combine different types of requirements in the same array and use the [maxRequirementsMet](/api/game/requirements/functions/maxRequirementsMet) function to calculate the maximum number of levels that could be acquired with the current requirement states.
